{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 14:23:13 "},"js/":{"url":"js/","title":"js","keywords":"","body":"css 描述 Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 16:23:28 "},"js/JavaScript六种继承方式.html":{"url":"js/JavaScript六种继承方式.html","title":"JavaScript六中继承方式","keywords":"","body":"六种继承方式 原型链 借用构造函数 组合继承（原型链+构造函数） 最常用 原型式继承 寄生式继承 寄生组合式继承 参考网址 JavaScript六种继承方式 layout 继承是面向对象编程中又一非常重要的概念，JavaScript支持实现继承，不支持接口继承，实现继承主要依靠原型链来实现的 1.原型链 原型链继承基本思想就是让一个原型对象指向另一个类型的实例 function Parent(){ this.property=true; } Parent.prototype.getParentValue=function(){ return this.property; } function Child(){ this.Childproperty=false; } Child.prototype=new Parent(); Child.prototype.getChildValue=function(){ return this.Childproperty; } var instance=new Child(); console.log(instance.getParentValue)//true; 代码定义了两个类型Parent和Child，每个类型分别由一个属性和一个方法，Child继承了Parent，而继承是通过创建Parent的实例，并将该实例赋给Child.prototype实现的。 实现的本质是重写原型对象，代之以一个新类型的实例，那么存在Parent的实例中的所有属性和方法，现在也存在于Child.prototype中了 我们知道，在创建一个实例的时候，实例对象中会有一个内部指针指向创建它的原型，进行关联起来，在这里代码Child.prptotype=new Parent(),也会在Child.prototype创建一个内部指针，将Child.prototype与Parent关联起来 所以instance指向Child的原型，Child的原型有指向Parent的原型，继而在instance在调用getParentVlaue()方法的时候，会顺着这条链一直往上找 添加方法 在给Child原型添加方法的时候，如果，父类上也有同样的名字，Child将会覆盖这个方法，达到重写的目的。但是这个方法依然存在于父类中 记住不能以字面量的形式添加，因为，上面说过通过实例继承本质上就是重写，在使用字面量形式，又是一次重写了，但这次重写没有跟父类有任何关联，所以就会导致原型链截断 function Parent(){ this.property=true; } Parent.prototype.getParentValue=function(){ return this.property; } function Child(){ this.Childproperty=false; } Child.prototype=new Parent(); Child.prototype={ getChildValue:function(){ return this.Childproperty; } } var instance=new Child(); console.log(instance.getParentValue)//error; 问题 单纯的使用原型链继承，主要问题来自包含引用类型的原型。 function Parent(){ this.colors=['red','blue','green']; } function Child(){ } Child.prototype=new Parent(); var instance1=new Child(); var instance2=new Child(); instance1.colors.push('black'); console.log(instance1.colors);//[\"red\", \"blue\", \"green\", \"black\"] console.log(instance2.colors);//[\"red\", \"blue\", \"green\", \"black\"] 在Parent构造函数定义了一个colors属性，当Child通过原型链继承后，这个属性就会出现Child.prototype中，就跟专门创建了Child.prototype.colors一样，所以会导致Child的所有实例都会共享这个属性，所以instance1修改colors这个引用类型值，也会反应到instance2中 2.借用构造函数 此方法为了解决原型中包含引用类型值带来的问题 这种方法的思想就是在子类构造函数的内部调用父类构造函数，可以借助apply()和call()方法来改变对象的执行上下文 function Parent(){ this.colors=['red','blue','green']; } function Child(){ Parent.call(this); } var instance1=new Child(); var instance2=new Child(); instance1.colors.push('black'); console.log(instance1.colors);//[\"red\", \"blue\", \"green\", \"black\"] console.log(instance2.colors);//[\"red\", \"blue\", \"green\"] 在新建Child实例是调用了Parent构造函数，这样一来，就会在新Child对象上执行Parent函数中定义的所有对象初始化代码。 结果，Child的每个实例就会具有自己的colors属性的副本了。 传递参数 借用构造函数还有一个优势就是可以传递参数 function Parent(name){ this.name=name; } Parent.prototype.say=function(){ console.log('hello'); } function Child(){ Parent.call(this,'Jiang'); this.job='student'; } var instance=new Child(); var parent=new Parent(); console.log(parent.say()); console.log(instance.name)//Jiang console.log(instance.job)//student console.log(instance.say());//error 问题 如果仅仅借助构造函数，方法都在构造函数中定义，因此函数无法达到复用。这种方法只能继承父构造函数中声明的实例属性，并没有继承父类原型的属性和方法，所以就找不到sayfa方法，为了同时继承父类原型，从而诞生了组合继承的方式。 3.组合继承（原型链+构造函数） 组合继承是将原型链继承和构造函数结合起来，从而发挥二者之长的一种模式 思路就是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承 这样，既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性 function Parent(name){ this.name=name; this.colors=['red','blue','green']; } Parent.prototype.sayName=function(){ console.log(this.name); } function Child(name,job){ Parent.call(this,name); this.job=job } Child.prototype=new Parent(); Child.prototype.constructor=Parent Child.prototype.sayJob=function(){ console.log(this.job); } var instance1=new Child('Jiang','student'); instance1.colors.push('black'); console.log(instance1.colors)//[\"red\", \"blue\", \"green\", \"black\"] instance1.sayName();//Jiang instance1.sayJob();//student var instance2=new Child('J','doctor'); console.log(instance2.colors)//[\"red\", \"blue\", \"green\"] instance2.sayName();//J instance2.sayJob();//doctor 这种模式避免了原型链和构造函数继承的缺陷，融合他们的优点，是最常用的一种继承模式 4.原型式继承 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型 function object(o){ function F(){} F.prototype=o; return new F(); } 在object函数内部，先创建一个临时性的构造函数，然后将传入的对象作为整个构造函数的原型，最后返回这个临时类型的一个实例 本质上来说，object对传入其中的对象执行了一次浅复制 var person={ name:'Jiang', friends:['Shelby','Court'] } var anotherPerson=object(person) console.log(anotherPerson.friends);//[\"Shelby\", \"Court\"] 这种模式要求你必须有一个对象作为另一个对象的基础 在这个例子中，person作为另一个对象的基础，把person传入object中，该函数就会返回一个新的对象 在这个新对象将person作为原型，所以它的原型中就包含一个基本类型和另一个引用类型 所以意味着如果还有另外一个对象关联了person，anotherPerson修改数组friends的时候，也会体现在这个对象中。 Object.create()方法 ES5通过Object.create()方法规范了原型式继承，可以接收两个参数，一个是作用新对象原型的对象和一个可选的为新对象定义额外属性的对象，行为相同，基本用法和上面的objcet一样，除了objcet不能接收第二个参数除外 var person={ name:'Jiang', friends:['Shelby','Court'] } var anotherPerson=Object.create(person) console.log(anotherPerson.friends);//[\"Shelby\", \"Court\"] 5.寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数 function createAnother(o){ var clone=Object.create(o);//创建一个新对象 clone.sayHi=function(){//添加方法 console.log('hi') } return clone//返回这个对象 } var person={ name:'Jiang' } var anotherPerson=createAnother(person); anotherPerson.sayHi(); 基于person返回了一个新对象anotherPerson,新对象不仅有用了person的属性和方法，还有自己的sayHi方法 在主要考虑对象而不是自定义类型和构造函数的情况下，这是一个有用的模式 6.寄生组合式继承 在前面说的组合模式（原型链+构造函数）中，继承的时候需要调用两次父类构造函数 父类 function Parent(name){ this.name=name; this.colors=['red','blue','green']; } 第一次在子类构造函数中 function Child(name,job){ //继承属性 Parent.call(this,name); this.job=job; } 第二次将子类的原型指向父类的实例 //继承方法 Child.prototype=new Parent(); 当使用var instance=new Child()的时候，会产生两组name和color属性，一组在Child实例上，一组在Child原型上，只不过实例上的屏蔽了原型上的。 使用寄生式组合模式，可以规避这个问题 这种模式通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 基本思路：不必为了执行子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本 本质上就是使用寄生式继承来继承父类的原型，在将结果指定给子类型的原型 function inheritPrototype(Child,Parent){ var prototype=Object.create(Parent.prototype) prototype.constructor=Child; Child.prototype=prototype; } 该函数实现了寄生组合继承的最简单模式 这个函数接受两个参数，一个子类，一个父类 第一步创建父类原型的副本，第二步将创建的副本添加construcot属性，第三步将子类的原型指向这个副本。 function Parent(){ this.name=name; this.colors=['red','blue','green'] } Parent.prototype.sayName=function(){ console.log(this.name); } function Child(name,job){ //继承属性 Parent.call(this,name) this.job=job; } //继承 inheritPrototype(Child,Parent) var instance=new Child('Jiang','student'); instance.sayName(); 补充：直接使用Object.create来实现，其实就是将上面封装的函数拆开，这样演示可以更容易理解 function Parent(){ this.name=name; this.colors=['red','blue','green'] } Parent.prototype.sayName=function(){ console.log(this.name); } function Child(name,job){ //继承属性 Parent.call(this,name) this.job=job; } //继承 Child.prototype=Object.create(Parent.prototype) //修复consrtuctor Child.prototype.constructor=Child; var instance=new Child('Jiang','Student') instance.sayName(); var instance=new Child('Jiang','student'); instance.sayName(); ES6新增了一个方法，Objcet.setPropertyOf,可以直接创建关联，而不用手动添加constructor属性 //继承 Object.setPropertyOf(Child.prototype,Parent.prototype) console.log(Child.prototype.constuctor===Child)//true Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 14:26:15 "},"js/极易被忽视的javascript面试题七问七答.html":{"url":"js/极易被忽视的javascript面试题七问七答.html","title":"极易被忽视的javascript面试题七问七答","keywords":"","body":"极易被忽视的javascript面试题七问七答 极易被忽视的javascript面试题七问七答 此题是我出的一套前端面试题中的最后一题，用来考核面试者的JavaScript的综合能力。 题目如下 function Foo(){ getName=function(){ console.log(1); } return this; } Foo.getName=function(){ console.log(2); } Foo.prototype.getName=function(){ console.log(3); } var getName=function(){ console.log(4); } function getName(){ console.log(5); } 请写出以下结果： Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName(); new new Foo().getName(); 此题是我综合之前的开发经验以及遇到的js各种坑汇集而成。此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性以及原型属性优先级等等。 此题包含7小文，分别如下： 第一问 先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName的函数。 第一问的Foo.getName自然是访问Foo函数上存储的静态属性，自然是2，没什么可说的。 第二问 第二问，直接调用getName函数。既然是直接调用那么就是访问当前上下文左右域内的叫getName的函数，所以跟1 2 3 都没什么关系。此题有无数面试者回答为5。此处有两个坑，一是变量声明提升，二是函数表达式。 1、变量声明提升 即所有声明变量或声明函数都会被提升到当前函数的顶部。 例如下代码： console.log('x' in window);//true var x; x=0; 代码执行时js引擎会将声明语句提升至代码最上方，变为： var x; console.log('x' in window);//true x=0; 2、函数表达式 var getName与fuction getName 都是声明语句，区别在于var getName是函数表达式，而function getName是函数声明。关于JS中的各种函数创建方式可以看大部分人都会做错的经典js闭包面试题，这篇文章有详细说明。 函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。 例如下代码： console.log(x);//输出:function x(){} var x=1; function x(){} 实际执行的代码为，先将var x=1拆分为var x；和x=1；两行，再将var x；和function x(){}两行提升至最上方变成： var x; function x(){}; console.log(x); x=1; 所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。 同理，原题中代码最终执行时的是： function Foo(){ getName=function(){ console.log(1); }; return this; } var getName;//只提升变量声明 function getName(){ console.log(5);//提升函数声明，覆盖var的声明 } Foo.getName=function(){ console.log(2); } Foo.prototype.getName=function(){ console.log(3); } getName=function(){ console.log(4); };//最终的赋值再次覆盖function getName声明 getName();//最终输出4 第三问 第三问的Foo().getName();先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。 Foo函数的第一句 getName=function(){console.log(1);};是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为function(){alert(1)}。 此处实际上是将外层作用域内的getName函数修改了。 注意： 此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。 之后Foo函数的返回值是this。而Js的this问题博客园已经有非常多的文章介绍，这里不再多说。 简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用当时，this指向window对象。 遂Foo函数返回的是window对象，相当于执行window.getName(),而window中的getName已经被修改为alert(1)，所以最终会输出1 此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。 第四问 直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1 第五问 第五问 new Foo.getName();此处考察的是js的运算符优先级问题。 通过查上表可以得知点(.)的优先级高于new操作，遂相当于： new (Foo.getname)(); 所以实际上将getName函数作为了够着函数来执行，遂弹出2。 第六问 第六问 new Foo().getName(),首先看运算符优先级括号高于new，实际执行位(new Foo()).getname() 遂先执行Foo函数，而Foo此时作为构造函数缺有返回值，所以这里需要说明下js中的构造函数返回值问题。 构造函数的返回值 在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。 而在js中构造函数可以有返回值也可以没有。 1、没有返回值则按照其他语言一样返回实例化对象。 > function F(){} new F() 2、若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本l类型（string，number，boolean，null，undefined）则与无返回值相同，实际返回其实例化对象。 > function F(){return true;} new F() 3、若返回值是引用类型，则实际返回值为这个引用类型。 > function F(){return true;} new F() 原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。 之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（protocol）中寻找getName，找到了。 遂最终输出3。 第七问 第七问，new new Foo().getName();同样是运算符优先级问题。 最终执行为： new ((new Foo()).getName)(); 先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。 遂最终结果为3 最后 就答题情况而言，第一问100%都可以回答正确，第二问大概只有50%正确率，第三问能回答正确的就不多了，第四问再正确就非常非常少了。其实此题并没有太多刁钻匪夷所思的用法，都是一些可能会遇到的场景，而大多数人但凡有1年到2年的工作经验都应该完全正确才对。 只能说有一些人太急躁太轻视了，希望大家通过此文了解js一些特性。 Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 14:28:08 "},"css/":{"url":"css/","title":"css","keywords":"","body":"Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 16:23:07 "},"css/盒子模型.html":{"url":"css/盒子模型.html","title":"盒子模型","keywords":"","body":"盒子模型 一、问题 题目：谈谈你对CSS盒模型的认识 1、基本概念：标准模型+IE模型 2、标准模型和IE模型的区别 3、CSS是如何设置这两种模型 4、js如何设置获取盒模型对应的宽和高 5、实例题（根据盒模型解释边距重叠） 6、BFC（边距重叠解决方案） 二、回答 1.基本概念 ​ 盒模型的组成，如下图，由里向外为content，padding、border、margin ​ 盒模型有两种标准：标准模型、IE模型 2.标准模型和IE模型的区别 标准模型：宽高=内容（content） IE模型：宽高=内容（content）+填充（padding）+边框（border） 3.CSS如何设置两种模型 使用css3中的属性box-sizing（浏览器默认的为标准模型） /*标准模型*/ box-sizing:content-box; /*IE模型*/ box-sizing：border-box; 4.CSS如何获取盒模型对应的宽和高 tip:dom表示获取的HTML节点 /*只能获取到内联样式的宽和高*/ 1. dom.style.width/height /*获取渲染以后的宽和高，仅IE支持*/ 2. dom.currentStyle.width/height /*补充2的不足，其余浏览器支持，获取渲染以后的宽和高*/ 3. window.getComputeStyle(dom).width/height /*计算一个元素的绝对位置，在视图以左上角为基点*/ 4.dom.getBoundingClientRect().width/height /**/ 5.dom.offsetWidth/offetHeight 5.实例题（根据盒模型解释边距重叠） 什么是边距重叠 6.BFC 1)BFC的基本概念 BFC（Block Formatting Context）：块级格式化上下文 1）BFC 的原理（渲染规则） 1、在BFC这个元素的垂直反向的边距会发生重叠 2、BFC的区域不会与浮动元素的box重叠 3、BFC在页面山是一个独立的元素，外面的元素不会影响它里面的元素，里面的元素也不会影响外面的元素 4、计算BFC高度的时候，浮动元素也会参与计算 2）如何创建BFC 1、float值不为null 2、position的值为absolute和fixed 3、display属性为inline-block，table-cell，table-caption，flex，inline-flex 4、overflow不为visible 3）应用场景 1、自适应两栏布局 2、清除内部浮动 3、防止垂直margin重叠 4、BFC子元素即使是float也会参与高度计算 ​ 参考链接 深入理解CSS盒模型 Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-23 18:09:43 "},"css/页面布局.html":{"url":"css/页面布局.html","title":"页面布局","keywords":"","body":"页面布局 一、问题 题目:假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应 提醒： float布局 绝对定位 flexbox 表格布局 网格布局 二、回答 代码结构,以float为例 *{ margin:0; padding:0; } .layout{ margin-top:20px; } .layout article>div{ min-height:100px; } 浮动解决方案 这是三栏布局中间部分 这是三栏布局中间部分 1.float布局 左 width:300px;float:left;background:red; 中 background:yellow; 右 width:300px;float:right;background:blue; 2.绝对定位 左中右都设置 position:absolute; 左 width:300px;left:0;background:red; 中 left:300px;right:300px;background:yellow; 右 width:300px;right:0;background:blue; 3.flex-box 左中右父类设置 display:flex; 左 width:300px; 中 flex:1;(重点) 右 width:300px; 4.表格布局 左中右父类设置 display:table;width:100%; 左中右都设置 display:table-cell; 左 width:300px;background:red; 中 background:yellow; 右 width:300px;background:blue; 5.网格布局 左中右父类设置 display:grid; width:100%; grid-template-rows:100px; grid-template-columns:300px auto 300px;(重点) 左 background:red; 中 background：yellow； 右 background:blue; 三、延伸与小结 1.延伸 1）. 这五种方案各有什么优缺点？ float: 缺点：清除浮动，浮动以后会脱离文档里流，处理不当会带来很多问题，本身有一定的局限性； 优点：兼容性比较好，需要处理好周围元素的关系。 绝对定位: 缺点：布局脱离了文档流，意味着下面所有子元素也必须脱离文档流，导致可使用性比较差。 优点：快捷，方便，配合js使用不容易出问题。 flex布局： 缺点：IE8不支持flex 优点:比较完美的方案，解决了上面两个方案的不足。 表格布局： 缺点：历史诟病，当某一个单元格的高度超出之后，两侧的单元格也是要调整高度的； 有时候的场景是不需要同时增高的 优点：轻易做到，兼容性好。 网格布局: 缺点：兼容性问题 优点：可以作很多复杂的事情，简化代码量。 2）. 如果把假设高度去掉，考虑纵向，左右内容撑高了，中间也需要撑高，哪些能使用，哪些不能使用？ flex和表格布局是可以通用的； float：为什么中间左右内容都超出来了？ float的基本原理：它的内容像左浮动的时候，被左侧的块挡住了， 所以它的文案在左边块的右边排的，当内容超出之后，它发现左侧没有遮挡物， 也就没有了float元素，就会向左排；若不想让中间超出部分转到左边，创建BFC 3）. 这五种方案的兼容性如何，业务中选出最优的方案？ 没有绝对的最优方案，需要根据业务需要来定 2.小结 > 语义化要到位 页面布局理解深刻 css基础知识扎实 思维灵活且积极上进 代码书写规范 3.布局变通思考 > 三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 山高度固定，下自适应 下高度固定，上自适应 四、思考 1. 如果五种方案，都不设置高度，会是什么样？ 2. BFC是什么 Copyright @QiangMin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-18 18:15:11 "}}